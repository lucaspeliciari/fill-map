#include <iostream>
#include <queue>
#include <fstream>
#include <math.h>
#include <chrono>

using namespace std;
using namespace std::chrono;

class Node 
{
    public:
    int x, y;
    Node(int posX, int posY)
    {
        x = posX;
        y = posY;
    }
};

typedef uint8_t  BYTE;
typedef uint32_t DWORD;
typedef int32_t  LONG;
typedef uint16_t WORD;

typedef struct
{
    WORD   bfType;
    DWORD  bfSize;
    WORD   bfReserved1;
    WORD   bfReserved2;
    DWORD  bfOffBits;
} __attribute__((__packed__))
BITMAPFILEHEADER;

typedef struct
{
    DWORD  biSize;
    LONG   biWidth;
    LONG   biHeight;
    WORD   biPlanes;
    WORD   biBitCount;
    DWORD  biCompression;
    DWORD  biSizeImage;
    LONG   biXPelsPerMeter;
    LONG   biYPelsPerMeter;
    DWORD  biClrUsed;
    DWORD  biClrImportant;
} __attribute__((__packed__))
BITMAPINFOHEADER;

typedef struct
{
    BYTE  b;
    BYTE  g;
    BYTE  r;
} __attribute__((__packed__))
COLOR; 

int index(int i, int j, int width, int height);
bool fill(int i, int j, int width, int height, COLOR* pixels, COLOR& currentColor);  // too many args
bool isWhite(COLOR pixel);
void setColor(COLOR& pixel, COLOR currentColor);
void incrementColor(COLOR& currentColor);


int main(int argc, char *argv[])
{
    auto start = high_resolution_clock::now();
    cout << "Starting" << endl;

    if (argc != 3)
    {
        cout << "Invalid argument: syntax is \"main.cpp [INFILE] [OUTFILE]\"" << endl;
        return 1;
    }

    string infile_path = argv[1];
    string outfile_path = argv[2];

    ifstream infile{infile_path, ios_base::binary};
    if (!infile)
    {
        cout << "Open error: could not open file at " << infile_path << endl;
        return 2;
    }

    BITMAPFILEHEADER fileHeader;
    infile.read((char*)&fileHeader, sizeof(BITMAPFILEHEADER));

    BITMAPINFOHEADER infoHeader;
    infile.read((char*)&infoHeader, sizeof(BITMAPINFOHEADER));

    if (fileHeader.bfType != 0x4d42)
    {
        cout << "Unsupported format: file is not BMP" << endl;
        return 3;
    }

    const int width = infoHeader.biWidth;
    const int height = infoHeader.biHeight;  // if positive starts from bottom-left
    int size = width * abs(height) * sizeof(COLOR);
    int padding = (4 - (width * sizeof(COLOR)) % 4) % 4;  // haven't tested with compression
    printf("Resolution: %ix%i, %i-bit  Padding: %i\n", width, abs(height), infoHeader.biBitCount, padding);

    COLOR* pixels = new COLOR[size/3];
    for (int i = 0; i < size/3; i += 1)
    {
        COLOR buffer;
        infile.read((char*)&buffer, sizeof(COLOR));
        pixels[i] = buffer;
    }

    infile.close();

    cout <<"Generating colors... ";
    int totalColors = 16056311;
    COLOR* colors = new COLOR[totalColors]; // all possible colors that can be generated by incrementColor()
    COLOR currentColor; currentColor.r = 10; currentColor.g = 10; currentColor.b = 10;
    colors[0] = currentColor;
    for (int i = 0; i < totalColors; i++)
    {
        incrementColor(currentColor);
        colors[i] = currentColor;
    }
    
    cout << "finished" << endl << totalColors << " colors generated" << endl;


    cout << "Filling map regions";
    srand (time(NULL));  // change seed for rand(), otherwise it will keep using the same
    bool* usableColors = new bool[totalColors];
    for (int i = 0; i < totalColors; i++) usableColors[i] = true;
    int colorIndex = 0;

    int percentStep = 33;
    for (int i = 0; i < width; i++)
    {   
        float percent = round(100 * i / width);
        if (percent >= percentStep) 
        {
            cout << ".";
            percentStep += 33;
        }
        for (int j = 0; j < height; j++)
        {
            if (fill(i, j, width, height, pixels, colors[colorIndex]))
            {
                usableColors[colorIndex] = false;
                while (!usableColors[colorIndex])
                {
                    colorIndex = rand() % totalColors;
                }
            }     
        }
    }
    int regionsPainted = 0;
    for (int i = 0; i < totalColors; i++) if (!usableColors[i]) regionsPainted++;
    cout << " finished" << endl << regionsPainted << " regions painted" << endl;

    cout << "Writing to file... ";
    ofstream outfile{outfile_path, ios_base::binary};
    if (!outfile)
    {
        cout << "Save error: could not create file at " << outfile_path << endl;
        return 4;
    }

    cout << "finished" << endl << "Writing header" << endl;
    outfile.write((char*)&fileHeader, sizeof(BITMAPFILEHEADER));
    outfile.write((char*)&infoHeader, sizeof(BITMAPINFOHEADER));

    cout << "Writing data" << endl;

    // for (int i = 0; i < pixels.size(); i++)
    for (int i = 0; i < size/3; i++)
    {
        COLOR pixel = pixels[i];
        outfile.write((char*)&pixel, sizeof(COLOR));
    }
    outfile.close();
    cout << "Finished writing successfuly" << endl;

    auto finish = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(finish - start);
    cout << "Program finished in " << duration.count() << " ms" << endl;

    return 0;
}


int index(int i, int j, int width, int height)
{
    if (i >= width)  // this is true sometimes with certain files, but it does not seem to break anything
    {
        cout << "Index error: index greater than width" << endl;
        return -1;
    }

    int startY = j;
    if (height > 0)
        startY = abs(height) - 1 - j;   // if height is positive, BMP starts from bottom-left instead of top-left

    int index = (i + startY * width);
    return index;
};


bool fill(int i, int j, int width, int height, COLOR* pixels, COLOR& currentColor)
{
    int curIndex = index(i, j, width, height);
    if (isWhite(pixels[curIndex]))
    {
        setColor(pixels[curIndex], currentColor);
        queue<Node> q;
        Node n(i, j);
        q.push(n);

        while (!q.empty())
        {
            Node p = q.front();
            q.pop();

            // up
            curIndex = index(p.x, p.y - 1, width, height);
            if (isWhite(pixels[curIndex]) && p.y - 1 >= 0)
            {
                setColor(pixels[curIndex], currentColor);
                Node newN(p.x, p.y-1);
                q.push(newN);
            }
            
            // right
            curIndex = index(p.x + 1, p.y, width, height);
            if (isWhite(pixels[curIndex]) && p.x + 1 < width)
            {
                setColor(pixels[curIndex], currentColor);
                Node newN(p.x+1, p.y);
                q.push(newN);
            }

            // down
            curIndex = index(p.x, p.y + 1, width, height);
            if (isWhite(pixels[curIndex]) && p.y + 1 < height)
            {
                setColor(pixels[curIndex], currentColor);
                Node newN(p.x, p.y+1);
                q.push(newN);
            } 

            // left
            curIndex = index(p.x - 1, p.y, width, height);
            if (isWhite(pixels[curIndex]) && p.x - 1 >= 0)
            {
                setColor(pixels[curIndex], currentColor);
                Node newN(p.x-1, p.y);
                q.push(newN);
            }
        }
       return true;
    }
    return false;
};


bool isWhite(COLOR pixel)
{
    if (pixel.r == 255 && pixel.g == 255 && pixel.b == 255) return true;
    else return false;
}


void setColor(COLOR& pixel, COLOR currentColor)
{
    pixel.r = currentColor.r; 
    pixel.g = currentColor.g; 
    pixel.b = currentColor.b;
}


void incrementColor(COLOR& currentColor)
{
    if (currentColor.r + 1 < 256)
        currentColor.r += 1;
    else
    {
        currentColor.r = 0;
        currentColor.g += 1;
    }
    if (currentColor.g >= 255)
    {
        currentColor.g = 0;
        currentColor.b += 1; 
    }
    return;
};
