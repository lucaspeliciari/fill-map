#include <ios>
#include <iostream>
#include <queue>
#include <fstream>
#include <stdio.h>
#include <vector>

#include <math.h>

#include <chrono>
using namespace std::chrono;

class Node 
{
    public:
    int x, y;
    Node(int posX, int posY)
    {
        x = posX;
        y = posY;
    }
};

typedef uint8_t  BYTE;
typedef uint32_t DWORD;
typedef int32_t  LONG;
typedef uint16_t WORD;

typedef struct
{
    WORD   bfType;
    DWORD  bfSize;
    WORD   bfReserved1;
    WORD   bfReserved2;
    DWORD  bfOffBits;
} __attribute__((__packed__))
BITMAPFILEHEADER;

typedef struct
{
    DWORD  biSize;
    LONG   biWidth;
    LONG   biHeight;
    WORD   biPlanes;
    WORD   biBitCount;
    DWORD  biCompression;
    DWORD  biSizeImage;
    LONG   biXPelsPerMeter;
    LONG   biYPelsPerMeter;
    DWORD  biClrUsed;
    DWORD  biClrImportant;
} __attribute__((__packed__))
BITMAPINFOHEADER;

typedef struct
{
    BYTE  b;
    BYTE  g;
    BYTE  r;
} __attribute__((__packed__))
COLOR; 

int index(int i, int j, int width, int height);
bool fill(int i, int j, int width, int height, std::vector<COLOR>& pixels, COLOR& currentColor);  // too many args
void incrementColor(COLOR& currentColor);


int main(int argc, char *argv[])
{
    auto start = high_resolution_clock::now();
    std::cout << "Starting" << std::endl;

    if (argc != 3)
    {
        std::cout << "Invalid argument: syntax is \"main.cpp [INFILE] [OUTFILE]\"" << std::endl;
        return 1;
    }

    std::string infile_path = argv[1];
    std::string outfile_path = argv[2];

    std::ifstream infile{infile_path, std::ios_base::binary};
    if (!infile)
    {
        std::cout << "Open error: could not open file at " << infile_path << std::endl;
        return 2;
    }

    BITMAPFILEHEADER fileHeader;
    infile.read((char*)&fileHeader, sizeof(BITMAPFILEHEADER));

    BITMAPINFOHEADER infoHeader;
    infile.read((char*)&infoHeader, sizeof(BITMAPINFOHEADER));

    if (fileHeader.bfType != 0x4d42 || fileHeader.bfOffBits != 54 || infoHeader.biSize != 40 ||
        infoHeader.biBitCount != 24 || infoHeader.biCompression != 0)
    {
        std::cout << "Unsupported format: file is not .bmp" << std::endl;
        return 3;
    }

    const int width = infoHeader.biWidth;
    const int height = infoHeader.biHeight;  // if positive starts from bottom-left
    int size = width * abs(height) * sizeof(COLOR);
    int padding = (4 - (width * sizeof(COLOR)) % 4) % 4;  // haven't tested with compression
    printf("Resolution: %ix%i, %i-bit  Padding: %i\n", width, abs(height), infoHeader.biBitCount, padding);

    std::vector<COLOR> pixels;
    for (int i = 0; i < size; i += 3)
    {
        COLOR buffer;
        infile.read((char*)&buffer, sizeof(COLOR));
        pixels.push_back(buffer);
    }
    std::cout << "Vector size: " << pixels.size() << "  OK: " << (pixels.size() == size / 3) << std::endl;

    infile.close();

    std::cout <<"Generating colors... ";
    int totalColors = 16056311;
    COLOR* colors = new COLOR[totalColors]; // all possible colors that can be generated by incrementColor()
    COLOR currentColor; currentColor.r = 10; currentColor.g = 10; currentColor.b = 10;
    colors[0] = currentColor;
    for (int i = 0; i < totalColors; i++)
    {
        incrementColor(currentColor);
        colors[i] = currentColor;
    }
    
    std::cout << "finished" << std::endl << totalColors << " colors generated" << std::endl;


    std::cout << "Filling map regions... " << std::endl;
    srand (time(NULL));  // change seed for rand(), otherwise it will keep using the same
    bool* usableColors = new bool[totalColors];
    for (int i = 0; i < totalColors; i++) usableColors[i] = true;
    int colorIndex = 0;

    int percentStep = 0;
    for (int i = 0; i < width; i++)
    {
        float percent = round(100 * i / width);
        if (percent >= percentStep)
        {
            std::cout << percent << " %" << std::endl;
            percentStep += 10;
        }
        for (int j = 0; j < height; j++)
        {
            if (fill(i, j, width, height, pixels, colors[colorIndex]))
            {
                usableColors[colorIndex] = false;
                while (!usableColors[colorIndex])
                {
                    colorIndex = rand() % totalColors;
                }
            }     
        }
    }
    int regionsPainted = 0;
    for (int i = 0; i < totalColors; i++) if (!usableColors[i]) regionsPainted++;
    std::cout << "Finished" << std::endl << regionsPainted << " regions painted" << std::endl;
    printf("COLOR CHECK: %i\n", totalColors);

    std::cout << "Writing to file... " << std::endl;
    std::ofstream outfile{outfile_path, std::ios_base::binary};
    if (!outfile)
    {
        std::cout << "Save error: could not create file at " << outfile_path << std::endl;
        return 4;
    }

    std::cout << "Writing header" << std::endl;
    outfile.write((char*)&fileHeader, sizeof(BITMAPFILEHEADER));
    outfile.write((char*)&infoHeader, sizeof(BITMAPINFOHEADER));

    std::cout << "Writing data" << std::endl;

    for (int i = 0; i < pixels.size(); i++)
    {
        COLOR pixel = pixels[i];
        outfile.write((char*)&pixel, sizeof(COLOR));
    }
    outfile.close();
    std::cout << "Finished writing successfuly" << std::endl;

    auto finish = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(finish - start);
    std::cout << "Program finished in " << duration.count() << " ms" << std::endl;

    return 0;
}


int index(int i, int j, int width, int height)
{
    if (i >= width)  // this is true sometimes with certain files, but it does not seem to break anything
    {
        std::cout << "Index error: index greater than width" << std::endl;
        return -1;
    }

    int startY = j;
    if (height > 0)
        startY = abs(height) - 1 - j;   // if height is positive, BMP starts from bottom-left instead of top-left

    int index = (i + startY * width);
    return index;
};


bool fill(int i, int j, int width, int height, std::vector<COLOR>& pixels, COLOR& currentColor)
{
    int curIndex = index(i, j, width, height);
    if (pixels[curIndex].r == 255 && pixels[curIndex].g == 255 && pixels[curIndex].b == 255)  // if pixel == WHITE
    {
        pixels[curIndex].r = currentColor.r; pixels[curIndex].g = currentColor.g; pixels[curIndex].b = currentColor.b;
        std::queue<Node> q;
        Node n(i, j);
        q.push(n);

        while (!q.empty())
        {
            Node p = q.front();
            q.pop();

            // up
            curIndex = index(p.x, p.y - 1, width, height);
            if (pixels[curIndex].r == 255 && pixels[curIndex].g == 255 && pixels[curIndex].b == 255 && p.y - 1 >= 0)
            {
                pixels[curIndex].r = currentColor.r; pixels[curIndex].g = currentColor.g; pixels[curIndex].b = currentColor.b;
                Node newN(p.x, p.y-1);
                q.push(newN);
            }
            
            // right
            curIndex = index(p.x + 1, p.y, width, height);
            if (pixels[curIndex].r == 255 && pixels[curIndex].g == 255 && pixels[curIndex].b == 255 && p.x + 1 < width)
            {
                pixels[curIndex].r = currentColor.r; pixels[curIndex].g = currentColor.g; pixels[curIndex].b = currentColor.b;
                Node newN(p.x+1, p.y);
                q.push(newN);
            }

            // down
            curIndex = index(p.x, p.y + 1, width, height);
            if (pixels[curIndex].r == 255 && pixels[curIndex].g == 255 && pixels[curIndex].b == 255 && p.y + 1 < height)
            {
                pixels[curIndex].r = currentColor.r; pixels[curIndex].g = currentColor.g; pixels[curIndex].b = currentColor.b;
                Node newN(p.x, p.y+1);
                q.push(newN);
            } 

            // left
            curIndex = index(p.x - 1, p.y, width, height);
            if (pixels[curIndex].r == 255 && pixels[curIndex].g == 255 && pixels[curIndex].b == 255 && p.x - 1 >= 0)
            {
                pixels[curIndex].r = currentColor.r; pixels[curIndex].g = currentColor.g; pixels[curIndex].b = currentColor.b;
                Node newN(p.x-1, p.y);
                q.push(newN);
            }
        }
        incrementColor(currentColor);
        return true;
    }
    return false;
};


void incrementColor(COLOR& currentColor)
{
    if (currentColor.r + 1 < 256)
        currentColor.r += 1;
    else
    {
        currentColor.r = 0;
        currentColor.g += 1;
    }
    if (currentColor.g >= 255)
    {
        currentColor.g = 0;
        currentColor.b += 1; 
    }
    return;
};
